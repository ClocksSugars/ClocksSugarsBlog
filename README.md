# ClocksSugarsBlog Haskell App
## This makes my website
You can find the website at [clockssugars.blog](https://clockssugars.blog/appliuni) although at the moment there is no home page, only an index. On the site you will find a textbook style blog in which I explain mathematics in such a way that any of my friends would be able to follow along. 

The entire website is generated by this code all at once in order to ensure that all links and references stay up to date and properly counted even if I need to go back and add or change a theorem or definition. Since it is generated from individual LaTeX sections, I can edit these files in [gummi LaTeX](https://alexandervdm.github.io/gummi/) which will show edits extremely quickly so long as your file is sufficiently small (which each section individually is). Under `latexraw` you will find the tex files corresponding to each of the sections in the appropriate folder corresponding to their chapter. Each chapter folder must also contain its assets, and for the sake of producing a latex pdf (at least for now) no two assets or sections may have the same name. Any new asset must be included in the manifest json in order to be loaded onto the website and all necessary assets must be listed in the depends field for its section to be copied into `public`. Once created, the entire `public` folder is uploaded with `scp -r ./public/ ...`.

## Functionality

If you want to run this code for yourself, I recommend you install [ghcup](https://www.haskell.org/ghcup/) and use it to install the recommended releases of ghc and cabal. I am (12/19/25) using ghcup 0.1.50.2 with ghc 9.6.7 and cabal 3.12.1.0.

In order to use the tool to generate a website, navigate to the folder in command line and run `cabal run . -- -m`. You can also modify the manifest json in order to add or remove chapters, but `cabal run . -- -e` will always restore the manifest to a working default. In order to produce a latex file, you'll need either XeLaTeX or LuaLaTeX, and due to some very strange properties of the svg package I use, you are not in for a good time. First, run `cabal run . -- -l` to produce the tex file in the `latexvomit` folder. Navigate to that folder and run either `xelatex -shell-escape appliunibook.tex` or `lualatex -shell-escape appliunibook.tex`. Some abominable error in some package means that when the commandline stops scrolling, you'll need to press Control-D a few times to get LaTeX to exit, at which point a pdf will be written just fine. You will however need to do this one more time in order to produce a pdf with references and a table of contents. At this point you will have a pdf file, along with an understanding of why the folder is called `latexvomit`.

## Some notes about how it works

The bulk of what is used when you call `cabal run . -- -m` is held in `SiteStructure` and `LatexToHtml`.

`LaTeXToHtml` deals primarily with how a single section is converted to a single page, and it has three stages, in `TreeCleaner` and `MainTools`. In `processOne` we take a latex syntax tree and convert it into something a little more list like, paying special attention to which environments will contain their own separate bodies of text such as infoboxes or lists; we also take this opportunity to flatten many math commands to text which KaTeX will eat on loading the webpage. In `processTwo` we pay special attention to which kinds of elements from the previous step are relevant to the grouping of paragraphs, which will need to be put in their own `<p>` braces where normally LaTeX would just handle that for us. In `processThree` we decide how each of the elements identified in previous steps are to be treated as HTML elements; the work associated with coloring and labelling infoboxes is shunted to `InfoBoxType` and the way that infoboxes create new references is handled in `ReferenceHandling`. `processThree` is also responsible for making sure that links or references to previous infoboxes are honored or numbered correctly.

In `SiteStructure` we handle creation of the index for appliuni, primarily in `WorkHorse`. The `IO (Maybe RefIndexState)` we progressively pass around, as an IO monad type, holds the state of the references but with the side effect that accessing it in any meaningful way runs the program that reads and writes relevant files. In `WorkHorse` we use functions defined in `LatexToHtml` to simultaneously write section pages while documenting the references each section creates as well as the section's title and description as specified in the manifest. Once this index is built up, it can be made into a page of its own. The sum of all the references together will be interesting at some point in the future I hope; eventually functionality should be added for seeing which theorems/definitions are referenced in which proof to render a theorem dependency graph.
